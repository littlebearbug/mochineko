---
# 博客分为四个大类: 1(技术世界)、2(游戏频道)、3(音乐随想)、4(生活碎笔)
title: 为什么你的移动端页面底部总被“吃掉”？彻底搞懂 CSS 中的 dvh, svh 和 lvh
description: 解析为何移动端 100vh 会被地址栏“吃掉”，详解 dvh/svh/lvh 的差异与适用场景，提供兼容回退与简单 CSS 示例，推荐用 dvh 实现稳健的全屏布局体验。
date: 2025-11-25
categories: [1]
tags: ['CSS', '*vh']
author: MochiNeko
draft: false
cover: https://pub.bearbug.dpdns.org/1760765176012-thumbnail.webp
---

你是否经历过这种绝望：你在开发一个全屏的 H5 页面（比如登录页或宣传海报），在电脑浏览器的模拟器里调试得完美无缺。然而，当你满怀期待地掏出 iPhone 或安卓手机打开它时，尴尬发生了——**页面最底部的“提交”按钮被浏览器的地址栏挡住了一半，甚至完全看不见。**

这不仅仅是你一个人的痛苦，这是前端开发中经典的 `100vh` 诅咒。

今天，我们就用一个最直观的模型，来彻底讲清楚这个问题，以及 2024 年最优雅的 CSS 解决方案。

## 场景还原：100px 的手机屏幕

为了把问题简单化，让我们假设你有一部极其迷你的“超酷手机”：

1.  **屏幕总高度**：100px。
2.  **浏览器 UI（地址栏/工具栏）**：这部分是可以伸缩的。
    *   **状态 A（刚加载时）**：UI 占据 **15px**。此时留给你网站的实际空间是 **85px**。
    *   **状态 B（开始滚动后）**：UI 变小，只占据 **10px**。此时留给你网站的实际空间变成了 **90px**。

### 传统的 `100vh` 错在哪里？

在很长一段时间里，移动端浏览器对于 `100vh` 的定义非常“固执”。为了避免用户在滚动页面时，背景或布局因为地址栏的收缩而疯狂跳动，浏览器厂商通常将 `100vh` 定义为**最大可能的视口高度**。

套用我们的模型：
*   浏览器认为 `100vh` = **90px**（即状态 B，UI 最小的时候）。

**灾难发生了：**
当用户刚打开页面（状态 A）时，实际可见区域只有 **85px**。但你的 CSS 写着 `height: 100vh`，浏览器就强行把页面渲染成 **90px** 高。

**结果：90px 的内容塞进 85px 的窗口，最底下的 5px 内容自然就被地址栏遮盖了。**

## 救世主登场：动态视口单位

为了解决这个痛点，CSS 引入了一组新的视口单位。它们完美对应了我们上面提到的不同状态。

### 1. `dvh` (Dynamic Viewport Height) —— 动态匹配

这是最推荐的解决方案，也是最符合直觉的单位。

`dvh` 会随着浏览器 UI 的伸缩而**实时变化**。
*   当你刚加载页面（状态 A）时，`100dvh` = **85px**。你的内容完美卡在地址栏上方。
*   当你滑动页面，地址栏收缩（状态 B）时，`100dvh` 自动变为 **90px**，填满扩大的屏幕。

**最佳使用场景：** 需要铺满全屏的首屏海报、全屏菜单。

```css
.full-screen-hero {
  /* 旧设备回退方案 */
  height: 100vh;
  /* 现代浏览器方案 */
  height: 100dvh;
}
```

> **注意**：由于 `dvh` 会随着滚动实时改变高度，如果你的页面布局非常复杂，这可能会带来极其轻微的性能消耗（因为浏览器在不断重绘），但在 99% 的情况下，这是可忽略的。

### 2. `svh` (Small Viewport Height) —— 保守匹配

`svh` 基于**最小**的视口可见区域（也就是 UI 最大的时候）。

套用模型：
*   无论是在状态 A 还是状态 B，`100svh` 始终等于 **85px**。

这意味着，当地址栏收缩时（可用空间变大），你的页面底部可能会出现一点空白（5px 的空隙），但你的内容**永远**不会被遮挡。

**最佳使用场景：** 页面内容非常关键，绝对不能被遮挡，且你不希望用户滚动时布局发生任何跳动。

### 3. `lvh` (Large Viewport Height) —— 激进匹配

`lvh` 基于**最大**的视口可见区域。

套用模型：
*   无论 UI 怎么变，`100lvh` 始终等于 **90px**。

这实际上就是传统 `100vh` 在移动端浏览器的默认行为。如果你使用了 `lvh`，你实际上是在告诉浏览器：“我不在乎底部那一点点内容被遮住，我要让页面看起来尽量高。”

## 总结一张表

回到我们的 100px 屏幕模型，假设当前浏览器处于**UI 较大（15px）**的初始状态：

| 单位 | 此时计算高度 | 实际视觉效果 | 评价 |
| :--- | :--- | :--- | :--- |
| **100vh** | **90px** | 底部 5px 被地址栏遮挡 | ❌ 传统方案的痛点 |
| **100lvh** | **90px** | 底部 5px 被地址栏遮挡 | 同上 |
| **100svh** | **85px** | 完美显示，但若地址栏收缩会留白 | 🛡️ 最安全 |
| **100dvh** | **85px** | 完美显示，随地址栏收缩自动填满 | ✅ **最推荐** |

## 最佳实践代码

虽然现在的浏览器支持度已经非常好了（主流浏览器均已支持），但为了保险起见，我们通常会写两行代码：

```css
.my-container {
  width: 100%;
  
  /* 1. 针对旧版本浏览器的回退（即使被遮挡也比没有高度强） */
  height: 100vh;
  
  /* 2. 针对现代浏览器的完美体验 */
  height: 100dvh;
}
```

告别繁琐的 JavaScript 计算，告别 `window.innerHeight` 的监听，拥抱 `dvh`，让你的移动端页面像原生 App 一样丝般顺滑吧！